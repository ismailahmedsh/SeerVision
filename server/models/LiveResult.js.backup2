const { getDb } = require('../config/database');

class LiveResult {
  static async create(resultData) {
    return new Promise((resolve, reject) => {
      try {
        const db = getDb();
        if (!db) {
          throw new Error('Database connection is not available');
        }

        const { cameraId, promptId, promptText, success, confidence, meta } = resultData;

        const query = `
          INSERT INTO live_results (cameraId, promptId, promptText, success, confidence, meta, ts)
          VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        `;

        db.run(query, [cameraId, promptId, promptText, success ? 1 : 0, confidence, meta ? JSON.stringify(meta) : null], function(err) {
          if (err) {
            console.error('Error creating live result:', err.message);
            reject(err);
          } else {
            console.log('Live result created with ID:', this.lastID);
            resolve({
              id: this.lastID,
              cameraId,
              promptId,
              promptText,
              success,
              confidence,
              meta,
              ts: new Date().toISOString()
            });
          }
        });
      } catch (error) {
        console.error('Error in create:', error.message);
        reject(error);
      }
    });
  }

  static async findByTimeRange(from, to, cameraId = null) {
    return new Promise((resolve, reject) => {
      try {
        const db = getDb();
        if (!db) {
          throw new Error('Database connection is not available');
        }

        let query = `
          SELECT * FROM live_results 
          WHERE datetime(ts) BETWEEN datetime(?) AND datetime(?)
        `;
        let params = [from, to];

        if (cameraId) {
          query += ' AND cameraId = ?';
          params.push(cameraId);
        }

        query += ' ORDER BY ts DESC';

        db.all(query, params, (err, rows) => {
          if (err) {
            console.error('Error finding live results by time range:', err.message);
            reject(err);
          } else {
            resolve(rows);
          }
        });
      } catch (error) {
        console.error('Error in findByTimeRange:', error.message);
        reject(error);
      }
    });
  }

  static async getSummary(from, to) {
    return new Promise((resolve, reject) => {
      try {
        const db = getDb();
        if (!db) {
          throw new Error('Database connection not available');
        }

        const query = `
          SELECT 
            COUNT(*) as totalDetections,
            AVG(confidence) as averageConfidence,
            COUNT(DISTINCT cameraId) as activeCameras
          FROM live_results 
          WHERE success = 1 
          AND datetime(ts) BETWEEN datetime(?) AND datetime(?)
        `;

        db.get(query, [from, to], (err, row) => {
          if (err) {
            console.error('Error getting summary:', err.message);
            reject(err);
          } else {
            resolve(row);
          }
        });
      } catch (error) {
        console.error('Error in getSummary:', error.message);
        reject(error);
      }
    });
  }

  static async getTopQueries(from, to, limit = 5) {
    return new Promise((resolve, reject) => {
      try {
        const db = getDb();
        if (!db) {
          throw new Error('Database connection not available');
        }

        const query = `
          SELECT 
            COALESCE(promptText, 'Unknown Query') as query,
            COUNT(*) as count,
            AVG(confidence) as confidence,
            MIN(ts) as firstUsed,
            MAX(ts) as lastUsed
          FROM live_results 
          WHERE success = 1 
          AND datetime(ts) BETWEEN datetime(?) AND datetime(?)
          GROUP BY promptText
          ORDER BY count DESC
          LIMIT ?
        `;

        db.all(query, [from, to, limit], (err, rows) => {
          if (err) {
            console.error('Error getting top queries:', err.message);
            reject(err);
          } else {
            resolve(rows);
          }
        });
      } catch (error) {
        console.error('Error in getTopQueries:', error.message);
        reject(error);
      }
    });
  }

  static async getCameraPerformance(from, to) {
    return new Promise((resolve, reject) => {
      try {
        const db = getDb();
        if (!db) {
          throw new Error('Database connection not available');
        }

        const query = `
          SELECT 
            c.id as cameraId,
            c.name,
            COUNT(*) as detections,
            AVG(lr.confidence) as confidence
          FROM live_results lr
          JOIN cameras c ON lr.cameraId = c.id
          WHERE lr.success = 1 
          AND datetime(lr.ts) BETWEEN datetime(?) AND datetime(?)
          GROUP BY lr.cameraId, c.name
          ORDER BY detections DESC
        `;

        db.all(query, [from, to], (err, rows) => {
          if (err) {
            console.error('Error getting camera performance:', err.message);
            reject(err);
          } else {
            resolve(rows);
          }
        });
      } catch (error) {
        console.error('Error in getCameraPerformance:', error.message);
        reject(error);
      }
    });
  }

  static async getTimeseriesDetections(from, to, timeRange = '7d') {
    return new Promise((resolve, reject) => {
      try {
        const db = getDb();
        if (!db) {
          throw new Error('Database connection not available');
        }

        let query;
        if (timeRange === '1h') {
          query = `
            WITH RECURSIVE time_buckets AS (
              SELECT datetime(?) as bucket_start
              UNION ALL
              SELECT datetime(bucket_start, '+1 minute')
              FROM time_buckets
              WHERE bucket_start < datetime(?)
            ),
            detections_per_bucket AS (
              SELECT 
                strftime('%Y-%m-%d %H:%M:00', tb.bucket_start) as bucket,
                COUNT(lr.id) as detections
              FROM time_buckets tb
              LEFT JOIN live_results lr ON 
                strftime('%Y-%m-%d %H:%M:00', lr.ts) = strftime('%Y-%m-%d %H:%M:00', tb.bucket_start)
                AND lr.success = 1
              GROUP BY tb.bucket_start
            )
            SELECT 
              bucket as t,
              COALESCE(detections, 0) as detections
            FROM detections_per_bucket
            ORDER BY bucket
          `;
        } else if (timeRange === '6h') {
          query = `
            WITH RECURSIVE time_buckets AS (
              SELECT datetime(?) as bucket_start
              UNION ALL
              SELECT datetime(bucket_start, '+5 minutes')
              FROM time_buckets
              WHERE bucket_start < datetime(?)
            ),
            detections_per_bucket AS (
              SELECT 
                strftime('%Y-%m-%d %H:%M:00', tb.bucket_start) as bucket,
                COUNT(lr.id) as detections
              FROM time_buckets tb
              LEFT JOIN live_results lr ON 
                strftime('%Y-%m-%d %H:%M:00', lr.ts) = strftime('%Y-%m-%d %H:%M:00', tb.bucket_start)
                AND lr.success = 1
              GROUP BY tb.bucket_start
            )
            SELECT 
              bucket as t,
              COALESCE(detections, 0) as detections
            FROM detections_per_bucket
            ORDER BY bucket
          `;
        } else if (timeRange === '24h') {
          query = `
            WITH RECURSIVE time_buckets AS (
              SELECT datetime(?) as bucket_start
              UNION ALL
              SELECT datetime(bucket_start, '+15 minutes')
              FROM time_buckets
              WHERE bucket_start < datetime(?)
            ),
            detections_per_bucket AS (
              SELECT 
                strftime('%Y-%m-%d %H:%M:00', tb.bucket_start) as bucket,
                COUNT(lr.id) as detections
              FROM time_buckets tb
              LEFT JOIN live_results lr ON 
                strftime('%Y-%m-%d %H:%M:00', lr.ts) = strftime('%Y-%m-%d %H:%M:00', tb.bucket_start)
                AND lr.success = 1
              GROUP BY tb.bucket_start
            )
            SELECT 
              bucket as t,
              COALESCE(detections, 0) as detections
            FROM detections_per_bucket
            ORDER BY bucket
          `;
        } else if (timeRange === '7d') {
          query = `
            WITH RECURSIVE time_buckets AS (
              SELECT datetime(?) as bucket_start
              UNION ALL
              SELECT datetime(bucket_start, '+1 hour')
              FROM time_buckets
              WHERE bucket_start < datetime(?)
            ),
            detections_per_bucket AS (
              SELECT 
                strftime('%Y-%m-%d %H:00:00', tb.bucket_start) as bucket,
                COUNT(lr.id) as detections
              FROM time_buckets tb
              LEFT JOIN live_results lr ON 
                strftime('%Y-%m-%d %H:00:00', lr.ts) = strftime('%Y-%m-%d %H:00:00', tb.bucket_start)
                AND lr.success = 1
              GROUP BY tb.bucket_start
            )
            SELECT 
              bucket as t,
              COALESCE(detections, 0) as detections
            FROM detections_per_bucket
            ORDER BY bucket
          `;
        } else {
          query = `
            WITH RECURSIVE time_buckets AS (
              SELECT datetime(?) as bucket_start
              UNION ALL
              SELECT datetime(bucket_start, '+1 day')
              FROM time_buckets
              WHERE bucket_start < datetime(?)
            ),
            detections_per_bucket AS (
              SELECT 
                strftime('%Y-%m-%d', tb.bucket_start) as bucket,
                COUNT(lr.id) as detections
              FROM time_buckets tb
              LEFT JOIN live_results lr ON 
                strftime('%Y-%m-%d', lr.ts) = strftime('%Y-%m-%d', tb.bucket_start)
                AND lr.success = 1
              GROUP BY tb.bucket_start
            )
            SELECT 
              bucket as t,
              COALESCE(detections, 0) as detections
            FROM detections_per_bucket
            ORDER BY bucket
          `;
        }

        db.all(query, [from, to], (err, rows) => {
          if (err) {
            console.error('Error getting timeseries detections:', err.message);
            reject(err);
          } else {
            resolve(rows);
          }
        });
      } catch (error) {
        console.error('Error in getTimeseriesDetections:', error.message);
        reject(error);
      }
    });
  }

  static async getTimeseriesConfidence(from, to, timeRange = '7d') {
    return new Promise((resolve, reject) => {
      try {
        const db = getDb();
        if (!db) {
          throw new Error('Database connection not available');
        }

        let query;
        if (timeRange === '1h') {
          query = `
            WITH RECURSIVE time_buckets AS (
              SELECT datetime(?) as bucket_start
              UNION ALL
              SELECT datetime(bucket_start, '+1 minute')
              FROM time_buckets
              WHERE bucket_start < datetime(?)
            ),
            confidence_per_bucket AS (
              SELECT 
                strftime('%Y-%m-%d %H:%M:00', tb.bucket_start) as bucket,
                AVG(lr.confidence) as avgConfidence,
                COUNT(lr.id) as count
              FROM time_buckets tb
              LEFT JOIN live_results lr ON 
                strftime('%Y-%m-%d %H:%M:00', lr.ts) = strftime('%Y-%m-%d %H:%M:00', tb.bucket_start)
                AND lr.success = 1
              GROUP BY tb.bucket_start
            )
            SELECT 
              bucket as t,
              CASE 
                WHEN count > 0 THEN avgConfidence
                ELSE NULL
              END as avgConfidence
            FROM confidence_per_bucket
            ORDER BY bucket
          `;
        } else if (timeRange === '6h') {
          query = `
            WITH RECURSIVE time_buckets AS (
              SELECT datetime(?) as bucket_start
              UNION ALL
              SELECT datetime(bucket_start, '+5 minutes')
              FROM time_buckets
              WHERE bucket_start < datetime(?)
            ),
            confidence_per_bucket AS (
              SELECT 
                strftime('%Y-%m-%d %H:%M:00', tb.bucket_start) as bucket,
                AVG(lr.confidence) as avgConfidence,
                COUNT(lr.id) as count
              FROM time_buckets tb
              LEFT JOIN live_results lr ON 
                strftime('%Y-%m-%d %H:%M:00', lr.ts) = strftime('%Y-%m-%d %H:%M:00', tb.bucket_start)
                AND lr.success = 1
              GROUP BY tb.bucket_start
            )
            SELECT 
              bucket as t,
              CASE 
                WHEN count > 0 THEN avgConfidence
                ELSE NULL
              END as avgConfidence
            FROM confidence_per_bucket
            ORDER BY bucket
          `;
        } else if (timeRange === '24h') {
          query = `
            WITH RECURSIVE time_buckets AS (
              SELECT datetime(?) as bucket_start
              UNION ALL
              SELECT datetime(bucket_start, '+15 minutes')
              FROM time_buckets
              WHERE bucket_start < datetime(?)
            ),
            confidence_per_bucket AS (
              SELECT 
                strftime('%Y-%m-%d %H:%M:00', tb.bucket_start) as bucket,
                AVG(lr.confidence) as avgConfidence,
                COUNT(lr.id) as count
              FROM time_buckets tb
              LEFT JOIN live_results lr ON 
                strftime('%Y-%m-%d %H:%M:00', lr.ts) = strftime('%Y-%m-%d %H:%M:00', tb.bucket_start)
                AND lr.success = 1
              GROUP BY tb.bucket_start
            )
            SELECT 
              bucket as t,
              CASE 
                WHEN count > 0 THEN avgConfidence
                ELSE NULL
              END as avgConfidence
            FROM confidence_per_bucket
            ORDER BY bucket
          `;
        } else if (timeRange === '7d') {
          query = `
            WITH RECURSIVE time_buckets AS (
              SELECT datetime(?) as bucket_start
              UNION ALL
              SELECT datetime(bucket_start, '+1 hour')
              FROM time_buckets
              WHERE bucket_start < datetime(?)
            ),
            confidence_per_bucket AS (
              SELECT 
                strftime('%Y-%m-%d %H:00:00', tb.bucket_start) as bucket,
                AVG(lr.confidence) as avgConfidence,
                COUNT(lr.id) as count
              FROM time_buckets tb
              LEFT JOIN live_results lr ON 
                strftime('%Y-%m-%d %H:00:00', lr.ts) = strftime('%Y-%m-%d %H:00:00', tb.bucket_start)
                AND lr.success = 1
              GROUP BY tb.bucket_start
            )
            SELECT 
              bucket as t,
              CASE 
                WHEN count > 0 THEN avgConfidence
                ELSE NULL
              END as avgConfidence
            FROM confidence_per_bucket
            ORDER BY bucket
          `;
        } else {
          query = `
            WITH RECURSIVE time_buckets AS (
              SELECT datetime(?) as bucket_start
              UNION ALL
              SELECT datetime(bucket_start, '+1 day')
              FROM time_buckets
              WHERE bucket_start < datetime(?)
            ),
            confidence_per_bucket AS (
              SELECT 
                strftime('%Y-%m-%d', tb.bucket_start) as bucket,
                AVG(lr.confidence) as avgConfidence,
                COUNT(lr.id) as count
              FROM time_buckets tb
              LEFT JOIN live_results lr ON 
                strftime('%Y-%m-%d', lr.ts) = strftime('%Y-%m-%d', tb.bucket_start)
                AND lr.success = 1
              GROUP BY tb.bucket_start
            )
            SELECT 
              bucket as t,
              CASE 
                WHEN count > 0 THEN avgConfidence
                ELSE NULL
              END as avgConfidence
            FROM confidence_per_bucket
            ORDER BY bucket
          `;
        }

        db.all(query, [from, to], (err, rows) => {
          if (err) {
            console.error('Error getting timeseries confidence:', err.message);
            reject(err);
          } else {
            resolve(rows);
          }
        });
      } catch (error) {
        console.error('Error in getTimeseriesConfidence:', error.message);
        reject(err);
      }
    });
  }
}

module.exports = LiveResult;

